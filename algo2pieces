import copy
# Cria tabuleiro
board = [
    ["3","3","0","3"],
    ["0","3","0","1r1"],
    ["2r1","3","1r2","3"],
    ["0","0","0","2r2"]
    ]

possible_pieces = ["1r1","1g1","1b1","1r2","1g2","1b2","1r3","1g3","1b3"]
respective_finish = ["2r1","2g1","2b1","2r2","2g2","2b2","2r3","2g3","2b3"]

# lista das peças usadas                
def used_pieces(board):
    pieces = []
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j][0] == "1":
                pieces.append(board[i][j])
    return pieces

def list_finish(board):
    pieces = []
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j][0] == "2":
                pieces.append(board[i][j])
    return pieces

# Dá a posição de uma peça
def pos_pieces(boardstate):
    pos_pieces = {}
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j][0] == "1":
                pos_pieces[board[i][j]] = (i,j)
    return pos_pieces

def pos_finish(board):
    pos_finishes = {}
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j][0] == "2":
                pos_finishes[board[i][j]] = (i,j)
    if len(pos_finishes) != 0:
        return pos_finishes
    return 0

#def pos_single_piece(piece)

# Dá a posição das posições finais
def pos_finish(board):
    pos_finishes = {}
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j][0] == "2":
                pos_finishes[board[i][j]] = (i,j)
    if len(pos_finishes) != 0:
        return pos_finishes
    return 0

# Verifica se soução já foi encontrada
def solution_check(used_pieces,list_finish,pos_pieces,pos_finish,new_board,board):
    global dic,dic1
    pieces = used_pieces(new_board)
    finishes = list_finish(board)
    for i in range(len(pieces)):
        key = pieces[i]
        key1 = finishes[i]
        print(i)
        if pos_pieces(new_board)[key] != pos_finish(board)[key1]:
            return "false"
    return "true"

# Dá os movimentos possíveis
def check_move(pos_pieces,used_pieces,new_board,board):
    moves_bool = {"move_up": False, "move_down": False, "move_left": False, "move_right": False}
    pos_pieces = pos_pieces(new_board) #posição das peças usadas
    pieces = used_pieces(board) #lista das peças usadas
    moves = [] #movimentos possíveis
    for i in range(len(pieces)):
        row,col = pos_pieces[pieces[i]]
        if col != 0 and board[row][col-1] != "3":
                moves_bool["move_left"] = True
        if col != len(board)-1 and board[row][col+1] != "3":
                moves_bool["move_right"] = True
        if row != 0 and board[row-1][col] != "3":
                moves_bool["move_up"] = True
        if row != len(board)-1 and board[row+1][col] != "3":
                moves_bool["move_down"] = True
    for key,value in moves_bool.items():
        if value:
            moves.append(key)
    return moves

memo = [board]
memo1 = [] #memoriza estados do tabuleiro para dar print
visited = [] 
counter = 0

#daqui pa cima deve tar fixe
#<---------------------------------------------------------------------------------->
#daqui pa baixo preciso acrescentar cenas

# Faz o movimento e retorna novos estados para memo1 
def do_move(check_move, pos_piece,board):
    global memo,memo1,counter
    flag = False
    if len(memo1) != 0:    
        memo = copy.deepcopy(memo1)
        memo1 = []
    for i in range(len(memo)):
        if flag:
            break
        piece_positions = pos_pieces(memo[i])
        moves = check_move(pos_piece,used_pieces,memo[i],board)
        for j in range(len(moves)):
            pieces = used_pieces(board)
            new_board = copy.deepcopy(memo[i])
            if moves[j] == "move_up":
                for value in piece_positions.values():
                    x,y = value
                    new_board[x][y] = "0"    
                while len(pieces) != 0:
                    for piece in range(len(pieces)):
                        key = pieces[piece]
                        x,y = piece_positions[key]
                        if x-1 != -1 and new_board[x-1][y] != "3" and new_board[x-1][y][0] != "1": #se tiverem 2 na mesma coluna isto dá errado
                            new_board[x-1][y] = key
                        else:
                            pieces.remove(key)    
                if new_board in visited:
                    continue
                else:
                    visited.append(new_board)
                memo1.append(new_board)
            elif moves[j] == "move_down":
                pieces.reverse()           
                for value in piece_positions.values():
                    x,y = value
                    new_board[x+1][y] = "0"    
                while len(pieces) != 0:
                    for piece in range(len(pieces)):
                        key = pieces[piece]
                        x,y = piece_positions[key]
                        if x+1 != len(new_board) and new_board[x+1][y] != "3" and new_board[x+1][y][0] != "1": #se tiverem 2 na mesma coluna isto dá errado
                            new_board[x+1][y] = key
                        else:
                            pieces.remove(key)    
                if new_board in visited:
                    continue
                else:
                    visited.append(new_board)
                memo1.append(new_board)
            elif moves[j] == "move_left":
                for value in piece_positions.values():
                    x,y = value
                    new_board[x][y] = "0"    
                while len(pieces) != 0:
                    for piece in range(len(pieces)):
                        key = pieces[piece]
                        x,y = piece_positions[key]
                        if y-1 != -1 and new_board[x][y-1] != "3" and new_board[x][y-1][0] != "1": #se tiverem 2 na mesma coluna isto dá errado
                            new_board[x][y-1] = key
                        else:
                            pieces.remove(key)    
                if new_board in visited:
                    continue
                else:
                    visited.append(new_board)
                memo1.append(new_board)
            elif moves[j] == "move_right":
                pieces.reverse()
                for value in piece_positions.values():
                    x,y = value
                    new_board[x][y] = "0"    
                while len(pieces) != 0:
                    for piece in range(len(pieces)):
                        key = pieces[piece]
                        x,y = piece_positions[key]
                        if y+1 != len(new_board) and new_board[x][y+1] != "3" and new_board[x][y+1][0] != "1": #se tiverem 2 na mesma coluna isto dá errado
                            new_board[x][y+1] = key
                        else:
                            pieces.remove(key)    
                if new_board in visited:
                    continue
                else:
                    visited.append(new_board)
                memo1.append(new_board)
            if solution_check(used_pieces,list_finish,pos_pieces,pos_finish,new_board,board): 
                flag = True
                print("Solução encontrada\n")
                break
    if memo1 == []:
        print("Solução não encontrada")
        
    counter += 1
                
#print do tabuleiro para análise
def print_board(memo):
    for i in range(len(memo)):
        print(f"{i+1}\n")
        for row in memo[i]:
            print("  ".join(row))
        print("\n")

print("Initial Board:")
print_board(memo)

print(f"counter: {counter}\n")
do_move(check_move,pos_pieces,board)
print_board(memo1)
